<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `ffi` mod in crate `mistralrs`."><title>mistralrs::llguidance::ffi - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="mistralrs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../../../static.files/storage-3a5871a4.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../mistralrs/index.html">mistralrs</a><span class="version">0.5.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module ffi</a></h2><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In mistralrs::<wbr>llguidance</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">mistralrs</a>::<wbr><a href="../index.html">llguidance</a></div><h1>Module <span>ffi</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.LlgCommitResult.html" title="struct mistralrs::llguidance::ffi::LlgCommitResult">LlgCommit<wbr>Result</a></dt><dd>Represents result from llg_commit_token()</dd><dt><a class="struct" href="struct.LlgConstraint.html" title="struct mistralrs::llguidance::ffi::LlgConstraint">LlgConstraint</a></dt><dt><a class="struct" href="struct.LlgConstraintInit.html" title="struct mistralrs::llguidance::ffi::LlgConstraintInit">LlgConstraint<wbr>Init</a></dt><dt><a class="struct" href="struct.LlgConstraintStep.html" title="struct mistralrs::llguidance::ffi::LlgConstraintStep">LlgConstraint<wbr>Step</a></dt><dt><a class="struct" href="struct.LlgMaskResult.html" title="struct mistralrs::llguidance::ffi::LlgMaskResult">LlgMask<wbr>Result</a></dt><dt><a class="struct" href="struct.LlgMatcher.html" title="struct mistralrs::llguidance::ffi::LlgMatcher">LlgMatcher</a></dt><dt><a class="struct" href="struct.LlgStopController.html" title="struct mistralrs::llguidance::ffi::LlgStopController">LlgStop<wbr>Controller</a></dt><dt><a class="struct" href="struct.LlgTokenizer.html" title="struct mistralrs::llguidance::ffi::LlgTokenizer">LlgTokenizer</a></dt><dt><a class="struct" href="struct.LlgTokenizerInit.html" title="struct mistralrs::llguidance::ffi::LlgTokenizerInit">LlgTokenizer<wbr>Init</a></dt></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><dl class="item-table"><dt><a class="constant" href="constant.LLG_DECODE_INCLUDE_SPECIAL.html" title="constant mistralrs::llguidance::ffi::LLG_DECODE_INCLUDE_SPECIAL">LLG_<wbr>DECODE_<wbr>INCLUDE_<wbr>SPECIAL</a></dt><dd>Include special tokens in the output.
They may look like &lt;|something|&gt;, &lt;something_else&gt;, or &lt;[12345]&gt; if they don’t have a name.</dd><dt><a class="constant" href="constant.LLG_DECODE_NONE.html" title="constant mistralrs::llguidance::ffi::LLG_DECODE_NONE">LLG_<wbr>DECODE_<wbr>NONE</a></dt><dd>Do not include special tokens, and keep invalid UTF-8 as is.</dd><dt><a class="constant" href="constant.LLG_DECODE_VALID_UTF8.html" title="constant mistralrs::llguidance::ffi::LLG_DECODE_VALID_UTF8">LLG_<wbr>DECODE_<wbr>VALID_<wbr>UTF8</a></dt><dd>Replace invalid UTF-8 with the replacement character.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.constraint_to_llg.html" title="fn mistralrs::llguidance::ffi::constraint_to_llg">constraint_<wbr>to_<wbr>llg</a></dt><dt><a class="fn" href="fn.llg_clone_constraint.html" title="fn mistralrs::llguidance::ffi::llg_clone_constraint">llg_<wbr>clone_<wbr>constraint</a></dt><dd>Clone the constraint</dd><dt><a class="fn" href="fn.llg_clone_matcher.html" title="fn mistralrs::llguidance::ffi::llg_clone_matcher">llg_<wbr>clone_<wbr>matcher</a></dt><dd>Clone the matcher.</dd><dt><a class="fn" href="fn.llg_clone_tokenizer.html" title="fn mistralrs::llguidance::ffi::llg_clone_tokenizer">llg_<wbr>clone_<wbr>tokenizer</a></dt><dd>Clone a tokenizer.
This increments a reference count and does a small allocation.</dd><dt><a class="fn" href="fn.llg_commit_token.html" title="fn mistralrs::llguidance::ffi::llg_commit_token">llg_<wbr>commit_<wbr>token</a></dt><dd>Commit the token sampled with the mask returned from llg_compute_mask().
Can be run on the critical path of sampling (is fast).
Returns 0 on success and -1 on error (use llg_get_error() to get the exact error).
When 0 is returned, the result is written to *res_p.</dd><dt><a class="fn" href="fn.llg_compute_mask.html" title="fn mistralrs::llguidance::ffi::llg_compute_mask">llg_<wbr>compute_<wbr>mask</a></dt><dd>Compute mask for the next token sampling
It typically takes up to a millisecond for a 100k tokenizer, so should be called in background.
Returns 0 on success and -1 on error (use llg_get_error() to get the exact error).
When 0 is returned, the result is written to *res_p.</dd><dt><a class="fn" href="fn.llg_constraint_init_set_defaults.html" title="fn mistralrs::llguidance::ffi::llg_constraint_init_set_defaults">llg_<wbr>constraint_<wbr>init_<wbr>set_<wbr>defaults</a></dt><dd>Set the default values for the ConstraintInit
Disables ff_tokens and backtracking, enables warnings on stderr
and all logging to the buffer (get with llg_flush_logs()).
You need to set the tokenizer field manually.</dd><dt><a class="fn" href="fn.llg_decode_tokens.html" title="fn mistralrs::llguidance::ffi::llg_decode_tokens">llg_<wbr>decode_<wbr>tokens</a><sup title="unsafe function">⚠</sup></dt><dd>Return a string representation of the tokens, useful for debugging.
The output is NUL-terminated.
Returns the number of bytes that would be written to output if output_len was large enough.
flags is one of LLG_DECODE_*</dd><dt><a class="fn" href="fn.llg_flush_logs.html" title="fn mistralrs::llguidance::ffi::llg_flush_logs">llg_<wbr>flush_<wbr>logs</a></dt><dd>Get the logs from the constraint, since last call to this function.
The logs are null-terminated.
The logs are kept in the constraint until the next call to this function
or until the constraint is freed.</dd><dt><a class="fn" href="fn.llg_free_constraint.html" title="fn mistralrs::llguidance::ffi::llg_free_constraint">llg_<wbr>free_<wbr>constraint</a><sup title="unsafe function">⚠</sup></dt><dd>Free the constraint</dd><dt><a class="fn" href="fn.llg_free_matcher.html" title="fn mistralrs::llguidance::ffi::llg_free_matcher">llg_<wbr>free_<wbr>matcher</a><sup title="unsafe function">⚠</sup></dt><dd>Free the matcher.</dd><dt><a class="fn" href="fn.llg_free_stop_controller.html" title="fn mistralrs::llguidance::ffi::llg_free_stop_controller">llg_<wbr>free_<wbr>stop_<wbr>controller</a><sup title="unsafe function">⚠</sup></dt><dd>Free the stop-sequence controller</dd><dt><a class="fn" href="fn.llg_free_tokenizer.html" title="fn mistralrs::llguidance::ffi::llg_free_tokenizer">llg_<wbr>free_<wbr>tokenizer</a><sup title="unsafe function">⚠</sup></dt><dd>Free the tokenizer. Should <em>NOT</em> be called while there are still constraints using it.</dd><dt><a class="fn" href="fn.llg_get_error.html" title="fn mistralrs::llguidance::ffi::llg_get_error">llg_<wbr>get_<wbr>error</a></dt><dd>Get the error message from the constraint or null if there is no error.
After it returns a non-null value, it will always return it until the constraint is freed
using llg_free_constraint() (at which point the pointer will be invalid).</dd><dt><a class="fn" href="fn.llg_get_temperature.html" title="fn mistralrs::llguidance::ffi::llg_get_temperature">llg_<wbr>get_<wbr>temperature</a></dt><dd>Get the current temperature of the constraint.
It is updated by mask computation.</dd><dt><a class="fn" href="fn.llg_is_stopped.html" title="fn mistralrs::llguidance::ffi::llg_is_stopped">llg_<wbr>is_<wbr>stopped</a></dt><dd>Check if constraint is stopped (cannot be extended further).</dd><dt><a class="fn" href="fn.llg_matcher_compute_ff_tokens.html" title="fn mistralrs::llguidance::ffi::llg_matcher_compute_ff_tokens">llg_<wbr>matcher_<wbr>compute_<wbr>ff_<wbr>tokens</a><sup title="unsafe function">⚠</sup></dt><dd>Compute the fast-forward (forced) tokens for the current state.
The result is written to output.
Returns the number of tokens written to output (which can be 0) or -1 on error.</dd><dt><a class="fn" href="fn.llg_matcher_compute_mask.html" title="fn mistralrs::llguidance::ffi::llg_matcher_compute_mask">llg_<wbr>matcher_<wbr>compute_<wbr>mask</a></dt><dd>Compute the set of allowed tokens for the current state.
Use llg_matcher_get_mask() to get the result.
Returns 0 on success and -1 on error.</dd><dt><a class="fn" href="fn.llg_matcher_compute_mask_into.html" title="fn mistralrs::llguidance::ffi::llg_matcher_compute_mask_into">llg_<wbr>matcher_<wbr>compute_<wbr>mask_<wbr>into</a><sup title="unsafe function">⚠</sup></dt><dd>Compute the set of allowed tokens for the current state.
The result is written to mask_dest.
mask_byte_len must be equal to llg_matcher_get_mask_byte_size().
Returns 0 on success and -1 on error.</dd><dt><a class="fn" href="fn.llg_matcher_consume_token.html" title="fn mistralrs::llguidance::ffi::llg_matcher_consume_token">llg_<wbr>matcher_<wbr>consume_<wbr>token</a></dt><dd>Advance the matcher by one token.
Returns 0 on success and -1 on error.</dd><dt><a class="fn" href="fn.llg_matcher_consume_tokens.html" title="fn mistralrs::llguidance::ffi::llg_matcher_consume_tokens">llg_<wbr>matcher_<wbr>consume_<wbr>tokens</a><sup title="unsafe function">⚠</sup></dt><dd>Advance the matcher by several tokens.
Returns 0 on success and -1 on error.</dd><dt><a class="fn" href="fn.llg_matcher_get_error.html" title="fn mistralrs::llguidance::ffi::llg_matcher_get_error">llg_<wbr>matcher_<wbr>get_<wbr>error</a></dt><dd>Get the error message from the matcher or null if there is no error.
After it returns a non-null value, it will always return it until the matcher is freed
using llg_free_matcher() (at which point the pointer will be invalid).</dd><dt><a class="fn" href="fn.llg_matcher_get_mask.html" title="fn mistralrs::llguidance::ffi::llg_matcher_get_mask">llg_<wbr>matcher_<wbr>get_<wbr>mask</a></dt><dd>Return pointer to the mask computed by llg_matcher_compute_mask(), if any.</dd><dt><a class="fn" href="fn.llg_matcher_get_mask_byte_size.html" title="fn mistralrs::llguidance::ffi::llg_matcher_get_mask_byte_size">llg_<wbr>matcher_<wbr>get_<wbr>mask_<wbr>byte_<wbr>size</a></dt><dd>Return pointer to the mask computed by llg_matcher_compute_mask(), if any.</dd><dt><a class="fn" href="fn.llg_matcher_is_accepting.html" title="fn mistralrs::llguidance::ffi::llg_matcher_is_accepting">llg_<wbr>matcher_<wbr>is_<wbr>accepting</a></dt><dd>Check if the grammar can fully accept the input.</dd><dt><a class="fn" href="fn.llg_matcher_is_error.html" title="fn mistralrs::llguidance::ffi::llg_matcher_is_error">llg_<wbr>matcher_<wbr>is_<wbr>error</a></dt><dd>Check if the matcher is in an error state.</dd><dt><a class="fn" href="fn.llg_matcher_is_stopped.html" title="fn mistralrs::llguidance::ffi::llg_matcher_is_stopped">llg_<wbr>matcher_<wbr>is_<wbr>stopped</a></dt><dd>Check if the matcher will force EOS token.
This returns true also in error state, as that is a forced stop.</dd><dt><a class="fn" href="fn.llg_matcher_reset.html" title="fn mistralrs::llguidance::ffi::llg_matcher_reset">llg_<wbr>matcher_<wbr>reset</a></dt><dd>Resets the matcher to the initial state.
A matcher in error state cannot be reset.
Returns 0 on success and -1 on error.</dd><dt><a class="fn" href="fn.llg_matcher_rollback.html" title="fn mistralrs::llguidance::ffi::llg_matcher_rollback">llg_<wbr>matcher_<wbr>rollback</a></dt><dd>Backtracks the matcher states by num_tokens.
Returns 0 on success and -1 on error.</dd><dt><a class="fn" href="fn.llg_matcher_validate_tokens.html" title="fn mistralrs::llguidance::ffi::llg_matcher_validate_tokens">llg_<wbr>matcher_<wbr>validate_<wbr>tokens</a><sup title="unsafe function">⚠</sup></dt><dd>Check how many tokens can be consumed from the given tokens.
Returns the number of tokens that can be consumed, or -1 on error.</dd><dt><a class="fn" href="fn.llg_new_constraint.html" title="fn mistralrs::llguidance::ffi::llg_new_constraint">llg_<wbr>new_<wbr>constraint</a></dt><dd>Create a new constraint from a grammar JSON string
Always returns a non-null value. Call llg_get_error() on the result to check for errors.</dd><dt><a class="fn" href="fn.llg_new_constraint_any.html" title="fn mistralrs::llguidance::ffi::llg_new_constraint_any">llg_<wbr>new_<wbr>constraint_<wbr>any</a></dt><dd>Create a new constraint with specified type
Type can be one of “regex”, “json_schema” (or “json”), “lark”, “llguidance” (or “guidance”)
Always returns a non-null value. Call llg_get_error() on the result to check for errors.</dd><dt><a class="fn" href="fn.llg_new_constraint_json.html" title="fn mistralrs::llguidance::ffi::llg_new_constraint_json">llg_<wbr>new_<wbr>constraint_<wbr>json</a></dt><dd>Create a new constraint from a given JSON schema
Always returns a non-null value. Call llg_get_error() on the result to check for errors.</dd><dt><a class="fn" href="fn.llg_new_constraint_lark.html" title="fn mistralrs::llguidance::ffi::llg_new_constraint_lark">llg_<wbr>new_<wbr>constraint_<wbr>lark</a></dt><dd>Create a new constraint from a given lark grammar
Always returns a non-null value. Call llg_get_error() on the result to check for errors.</dd><dt><a class="fn" href="fn.llg_new_constraint_regex.html" title="fn mistralrs::llguidance::ffi::llg_new_constraint_regex">llg_<wbr>new_<wbr>constraint_<wbr>regex</a></dt><dd>Create a new constraint from a given regular expression
Always returns a non-null value. Call llg_get_error() on the result to check for errors.</dd><dt><a class="fn" href="fn.llg_new_matcher.html" title="fn mistralrs::llguidance::ffi::llg_new_matcher">llg_<wbr>new_<wbr>matcher</a><sup title="unsafe function">⚠</sup></dt><dd>Create a new matcher from the given ConstraintInit
Always returns a non-null value. Call llg_matcher_get_error() on the result to check for errors.
init.ff_tokens_ok and init.backtrack_ok are ignored
(backtracking is always disabled, and ff_tokens can be retrieved using llg_matcher_compute_ff_tokens()).
The data is of different format, depending on constraint_type:</dd><dt><a class="fn" href="fn.llg_new_stop_controller.html" title="fn mistralrs::llguidance::ffi::llg_new_stop_controller">llg_<wbr>new_<wbr>stop_<wbr>controller</a><sup title="unsafe function">⚠</sup></dt><dd>Create a new stop-sequence controller</dd><dt><a class="fn" href="fn.llg_new_tokenizer.html" title="fn mistralrs::llguidance::ffi::llg_new_tokenizer">llg_<wbr>new_<wbr>tokenizer</a></dt><dd>Construct a new tokenizer from the given TokenizerInit</dd><dt><a class="fn" href="fn.llg_par_compute_mask.html" title="fn mistralrs::llguidance::ffi::llg_par_compute_mask">llg_<wbr>par_<wbr>compute_<wbr>mask</a><sup title="unsafe function">⚠</sup></dt><dd>Compute mask for several constraints in parallel.</dd><dt><a class="fn" href="fn.llg_stop_commit_token.html" title="fn mistralrs::llguidance::ffi::llg_stop_commit_token">llg_<wbr>stop_<wbr>commit_<wbr>token</a></dt><dd>Commit a token to the stop-sequence controller.
Returns a valid utf8 string to be returned to the user (which can be empty)
and whether the sequence should be then finished.
The string is valid until the next call to this function, or until the stop-sequence controller is freed.</dd><dt><a class="fn" href="fn.llg_stringify_tokens.html" title="fn mistralrs::llguidance::ffi::llg_stringify_tokens">llg_<wbr>stringify_<wbr>tokens</a><sup title="unsafe function">⚠</sup></dt><dd>Return a string representation of the tokens, useful for debugging.
The output is NUL-terminated.
Returns the number of bytes that would be written to output if output_len was large enough.</dd><dt><a class="fn" href="fn.llg_tokenize_bytes.html" title="fn mistralrs::llguidance::ffi::llg_tokenize_bytes">llg_<wbr>tokenize_<wbr>bytes</a><sup title="unsafe function">⚠</sup></dt><dd>Tokenize the given bytes and return the tokens.
Always returns the number of tokens that would be written to output_tokens
if output_tokens_len was large enough.</dd><dt><a class="fn" href="fn.llg_tokenize_bytes_marker.html" title="fn mistralrs::llguidance::ffi::llg_tokenize_bytes_marker">llg_<wbr>tokenize_<wbr>bytes_<wbr>marker</a><sup title="unsafe function">⚠</sup></dt><dd>Tokenize the given bytes and return the tokens.
Special tokens will be tokenized, if they follow 0xFF byte prefix.
Always returns the number of tokens that would be written to output_tokens
if output_tokens_len was large enough.</dd><dt><a class="fn" href="fn.llg_validate_grammar.html" title="fn mistralrs::llguidance::ffi::llg_validate_grammar">llg_<wbr>validate_<wbr>grammar</a><sup title="unsafe function">⚠</sup></dt><dd>Check if given grammar is valid.
This about twice as fast as creating a matcher (which also validates).
See llg_new_matcher() for the grammar format.
Returns 0 on success and -1 on error and 1 on warning.
The error message is written to error_string.
The error_string is NUL-terminated.
Same for warning_string.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.LlgCallback.html" title="type mistralrs::llguidance::ffi::LlgCallback">LlgCallback</a></dt><dd>Function which llg calls when an operation is done.</dd><dt><a class="type" href="type.LlgToken.html" title="type mistralrs::llguidance::ffi::LlgToken">LlgToken</a></dt><dt><a class="type" href="type.LlgTokenizeFn.html" title="type mistralrs::llguidance::ffi::LlgTokenizeFn">LlgTokenize<wbr>Fn</a></dt><dd>Tokenization function
Will not write more than output_tokens_len tokens (which can be 0)
Returns the total number of tokens (which can be more than output_tokens_len)
This function has to be thread-safe!</dd></dl></section></div></main></body></html>